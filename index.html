<html>
<head>
    <title>Kremlin towers</title>
    <meta charset="utf-8" />
<script src="phaser.js"></script>
<script type="text/javascript">
    var config = {
        type: Phaser.AUTO,
        width: 1136,
        height: 640,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: {y: 10},
                debug: true,
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };
    var level = {
        playerTower: 
            {
                x: 50,
                y: 430,
            },
        towers: [
            {
                x: 100,
                y: 450,
                player: 1
            },
            {
                x: 700,
                y: 300, 
                player: 2
            },
            {
                x: 300,
                y: 450,
                player: 2
            },
        ]
    };
    var state = {
        cannon : {
            x: 200,
            y: 200
        },
        active: true,
        inaims: false,
        aimlength: 0,
        lastFireTime: 0
    };

    var vector;
    var aimline;
    var explosion;

    var game = new Phaser.Game(config);

    var cannons = [];
    var current_cannon = 0;
    var shells = [];
    var id = 0;
    var collisionLayer;
    var towersGroup;
    var shellsGroup;

    function preload() {
        this.load.tilemapTiledJSON('map', 'assets/map1.json');
        this.load.image('bullet', 'assets/bullet.png');
        this.load.image('cannon', 'assets/cannon.png');
        this.load.image('tower_selected', 'assets/tower_selected.png');
        this.load.image('background', 'assets/background.jpg');
        this.load.image('tower', 'assets/tower.png');
        this.load.image('tiles', 'assets/tiles.png');
        this.load.image('shell', 'assets/shell.png');
        this.load.spritesheet('explosion', 'assets/explosion.png', { frameWidth: 64, frameHeight: 64, endFrame: 25});
    }
    function create() {
        towersGroup = this.add.group();
        shellsGroup = this.add.group();

        this.add.tileSprite(595, 320, 1190, 640, 'background');
        map = this.add.tilemap('map');
        var tiles = map.addTilesetImage('tiles');
        collisionLayer = map.createStaticLayer('kremlin', tiles);
        collisionLayer.setCollision([20,21,22,23,24,25,26],true);
        var player1_towers = map.createFromTiles(22);
        var player2_towers = map.createFromTiles(21);

        // Создание всех башен

        for (let tower of player1_towers) {
            cannons.push(createTower(this, tower, 1));
        }
        for (let tower of player2_towers) {
            cannons.push(createTower(this, tower, 2));
        }
        // Выделяем текущую башню
        cannons[current_cannon].tower.setTexture('tower_selected');

        // Создаём графический лучик от пушки к курсору
        vector = this.add.graphics({ lineStyle: { width: 4, color: 0xaa00aa } });

        // Создаём анимированный взрыв
        explosion = this.add.sprite(0, 0, 'explosion');
        this.anims.create({
            key: 'explode',
            frames: this.anims.generateFrameNumbers('explosion', { start: 0, end: 23, first: 23 }),
            frameRate: 20
        });
    }

    function update () {
        this.physics.overlap(towersGroup, shellsGroup, killTower, null, this);
        // set the angle according to the mouse pointer
        if (this.input.activePointer.isDown && state.active) {
            state.inaims = true;
            mouseX = this.input.x;
            mouseY = this.input.y;
            cannonX = cannons[current_cannon].x;
            cannonY = cannons[current_cannon].y;
            var aimline = new Phaser.Geom.Line(cannonX, cannonY, mouseX, mouseY);
            vector.clear()
            vector.strokeLineShape(aimline);
            realAngle = Math.atan2(mouseY - cannonY, mouseX - cannonX) * 180 / Math.PI;
            unrealAngle = realAngle + 180;
            if (check_angle(cannons[current_cannon].allowable_angle, unrealAngle)) {
                cannons[current_cannon].sprite.angle = unrealAngle;
                state.aimlength = Phaser.Geom.Line.Length(aimline).toFixed(0);
            }
        } else if (state.inaims == true) { 
            fire(this, state.aimlength);
            state.active = false;
            state.lastFireTime = Date.now();
            state.inaims = false;
        }


        if (Date.now() - state.lastFireTime > 1000) {
            state.active = true;
        }
    }

    /* -- Фабрика башен. 
    
    API:
    createTower(obj,                  -- Объект в котором создаётся башня
                [x_coord, y_coord],   -- Координаты центра башни
                player,               -- Игрок 1 - левый, 2 - правый



     ) */

    function createTower(obj, tower, player) {
        var cannon = {
            x: 0,
            y: 0,
            player: player,

        };

        hideTile(tower);

        cannon.tower = obj.add.sprite(tower.x + 16, tower.y - 32, 'tower');
        var angle;
        if (cannon.player == 1) {
            cannon.x = tower.x + 30;
            angle = 0;
            cannon.allowable_angle = [[0,90], [270,360]];
        } else {
            cannon.x = tower.x;
            angle = 180;
            cannon.allowable_angle = [[90,270]];
        }

        cannon.y = tower.y - 20;
        cannon.sprite = obj.add.sprite(cannon.x, cannon.y, 'cannon');
        cannon.sprite.angle = angle;
        towersGroup.add(cannon.tower);
        return cannon;
    }


    function fire(game, aa) {
        vector.clear()
        cannons[current_cannon].tower.setTexture('tower');
        // запустить снаряд
        angle = cannons[current_cannon].sprite.angle;
        var shell = game.physics.add.image(cannons[current_cannon].x, cannons[current_cannon].y, 'shell').setActive();

        shell.body.center.setTo(0.5, 0.5);
        shell.setAngle(angle);
        shell.setAngularDrag(1.0);
        game.physics.add.collider(shell, collisionLayer, rocket_explode, null, this);
        game.physics.add.collider(shell, towersGroup, killTower, null, this);

        // Вот тут мы вызываем обратные тригонометрические функции.
        // Если игра будет лагать, можно будет заоптимизировать, передавая сразу вектор

        shell.setVelocityX(aa * Math.cos(angle * Math.PI / 180));
        shell.setVelocityY(aa * Math.sin(angle * Math.PI / 180));
        shell.id = id;
        id++;
        shellsGroup.add(shell);
        shells.push(shell);

        current_cannon = (current_cannon + 1) % cannons.length;
        cannons[current_cannon].tower.setTexture('tower_selected');
        /*for (let s of shells) {
            console.info('shell ' + s.id + 
                '@(' + s.x + ', ' + s.y + ')' +
                '-> (' + s.body.velocity.x + ', ' + s.body.velocity.y + ')');
        }*/
    }


    // Проверка, что пушка в башне не вылезает за границы разрешенных ей углов.
    // Использование: check_angle( [ [нижняя_граница, верхняя_граница], [нижняя_граница, верхняя граница] ], angle)

    function check_angle(allowable, angle) {
        for (let borders of allowable) {
            if (angle >= borders[0] && angle <= borders[1]) {
                return true;
            }
        }
        return false;
    }

    // Переопределение взрыва ракеты
    // Здесь, по идее, надо делать выборку всех объектов, расположенных в радиусе x от ракеты и убивать их.
    // Проверять, если среди объектов была башня, устранять её объект из массива
    // Если чьи нить башни кончились, то гамовер.

    function rocket_explode(shell, obj) {
        if (obj.index == -1) {
            return;
        }
        console.info(obj);
        explosion.x = obj.pixelX + (obj.width / 2);
        explosion.y = obj.pixelY - (obj.height / 2);
        explosion.anims.play('explode');
        shell.destroy();
        obj._alpha = 0;
        obj.collideUp = false;
        obj.collideDown = false;
        obj.collideLeft = false;
        obj.collideRight = false;
        collisionLayer.dirty = true;    
    }

    function hideTile(obj) {
        obj._alpha = 0;
        obj.collideUp = false;
        obj.collideDown = false;
        obj.collideLeft = false;
        obj.collideRight = false;
        collisionLayer.dirty = true;         
    }

    function killTower(shell, obj) {
        console.info('collide');
        explosion.x = obj.pixelX + (obj.width / 2);
        explosion.y = obj.pixelY - (obj.height / 2);
        explosion.anims.play('explode');
        shell.destroy();
        obj.destroy();
    }

</script>
</head>
<body>
</body>
</html>
